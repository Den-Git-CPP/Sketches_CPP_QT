# QWidget::closeEvent()    
https://runebook.dev/en/articles/qt/qwidget/closeEvent    
https://www.learnqt.guide/working-with-events

## Распространённые ошибки. 
### Неправильная Обработка событий:
- Неправильный вызов closeEvent() базового класса
Если вы вызовете QWidget::closeEvent(event) до выполнения пользовательской логики, виджет может быть закрыт преждевременно.
- Неправильное игнорирование события
Если вы вызовете event->ignore() без соответствующих условий, виджет может закрыться не так, как ожидалось.
- Не принимаю участие в мероприятии
Если вы забудете вызвать event->accept() в своей пользовательской реализации closeEvent(), виджет не закроется.   
Устранение неполадок   
- Проверьте порядок вызовов функций
Вызывайте QWidget::closeEvent(event) в соответствии с вашей пользовательской логикой, чтобы обеспечить надлежащую обработку событий.
- Проверьте логику обработки событий
Убедитесь, что вы вызываете event->accept() или event->ignore() в зависимости от желаемого поведения.

### Бесконечные циклы или Рекурсия:
Если ваша реализация closeEvent() вызывает другие функции или методы, которые запускают дополнительные вызовы closeEvent(), это может привести к бесконечным циклам или рекурсии.   
Устранение неполадок   
- Избегайте ненужных вызовов close()
Будьте осторожны при вызове close() внутри closeEvent(), так как это может привести к неожиданному поведению.
- Идентификация и прерывание рекурсивных вызовов
Убедитесь, что ваш код не создаёт циклических зависимостей, которые вызывают многократные вызовы closeEvent()

### Потеря данных или утечка ресурсов:
Если вы не позаботитесь должным образом о сохранении данных или очистке ресурсов в своей программе closeEvent(), вы можете потерять данные или столкнуться с утечкой памяти.   
Устранение неполадок
- Высвобождение ресурсов
Убедитесь, что вы освободили все выделенные ресурсы (например, память, дескрипторы файлов), чтобы предотвратить утечки.
- Внедрите надлежащие механизмы сохранения данных
Используйте соответствующие методы для сохранения несохраненных данных перед закрытием виджета.
### Конфликтующие Обработчики Событий:
Если несколько обработчиков событий (например, из родительских или дочерних виджетов) пытаются управлять поведением при закрытии, это может привести к конфликтам.   
Устранение неполадок
- Используйте фильтры событий
При необходимости используйте фильтры событий, чтобы изменять или блокировать события до того, как они попадут в виджет closeEvent().
- Расставьте приоритеты при обработке событий
Определите, какой обработчик событий должен иметь приоритет, и соответствующим образом скорректируйте логику обработки.
- Некоторые платформы могут иметь особые требования или особенности поведения, связанные с closeEvent().
- Тестирование на разных платформах
Протестируйте своё приложение на различных платформах, чтобы выявить и устранить проблемы, характерные для каждой из них.
- Ознакомьтесь с документацией платформы
Ознакомьтесь с документацией для вашей целевой платформы, чтобы узнать о конкретных рекомендациях или ограничениях.

### Вызов базовой реализации
Если вы хотите выполнить действие по закрытию по умолчанию (например, уничтожить виджет), вам следует вызвать реализацию базового класса QWidget::closeEvent() после своей пользовательской логики.

### Переопределение пользовательского поведения
Основная цель QWidget::closeEvent() — предоставить вам механизм для настройки поведения ваших виджетов при их закрытии. Вы можете переопределить эту функцию в производном классе и реализовать собственную логику, например:
- Подтверждение закрытия
Предложите пользователю подтвердить в диалоговом окне, действительно ли он хочет закрыть виджет.
- Сохранение данных
Сохраните все несохраненные данные перед закрытием виджета.
Выполнение задач очистки
Выполните все необходимые операции по очистке, такие как высвобождение ресурсов или остановка фоновых задач.
~~~~~~~
void MyWidget::closeEvent(QCloseEvent *event)
{
    // Your custom closing logic here

    QWidget::closeEvent(event);
}
~~~~~~~

# Event Object
- accept()   
Вызов accept() для объекта события указывает на то, что вы принимаете операцию закрытия и виджет будет закрыт.   
- ignore()   
Вызов ignore() для объекта события указывает на то, что вы отклоняете операцию закрытия и виджет останется открытым.   

## Пример: Подтверждение закрытия CloseEvent_1.  
## Пример: Сохранение Несохраненных данных CloseEvent_2.   
В этом примере проверяется, были ли изменены данные. Если да, то пользователю предлагается сохранить изменения. Если пользователь выбирает сохранение, а операция сохранения завершается ошибкой, событие игнорируется, и виджет остаётся открытым.

## Пример: Пользовательская очистка CloseEvent_3.   
В этом примере перед вызовом базового класса closeEvent() выполняются пользовательские задачи по очистке. Это гарантирует, что все необходимые задачи по очистке будут выполнены до уничтожения виджета.

## Пример: Подключение QAction или QShortcut к пользовательскому слоту CloseEvent_4.  
В этом примере подключается QAction или QShortcut к пользовательскому слоту, который выполняет нужную логику закрытия. Для этого создайте QTimer и подключите его сигнал таймера к слоту, который выполняет логику закрытия. Задайте таймеру нужный интервал.